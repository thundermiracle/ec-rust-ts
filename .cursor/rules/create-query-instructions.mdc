---
description: 
globs: 
alwaysApply: false
---
# クエリエンドポイント作成手順書

このドキュメントでは、Clean Architectureパターンに従って新しいクエリエンドポイントを作成する手順を説明します。

## アーキテクチャ概要

本プロジェクトは以下の層構造に従っています：

```
src/
├── domain/              # ドメイン層：ビジネスルールと企業ロジック
├── application/         # アプリケーション層：ユースケースとビジネスロジック
├── infrastructure/      # インフラストラクチャ層：外部との接続
└── presentation/        # プレゼンテーション層：HTTPインターフェース
```

## 実装パターン

### シンプルなリスト取得エンドポイント（例：/colors）

- パラメータなし
- リスト形式のデータ返却
- ページネーションなし

### 複雑なリスト取得エンドポイント（例：/products）  

- ページネーション対応
- リッチなデータ構造
- ビジネスロジック含む

### パラメータ付きエンドポイント（例：/variants）

- POSTリクエスト
- リクエストボディでパラメータ受け取り
- 複雑な検索条件対応

## ステップバイステップ実装手順

### Step 1: Application層 - DTO作成

#### 1.1 DTOファイル作成

```bash
touch src/application/dto/your_entity_list_dto.rs
```

複数データを取得する場合

```rust
// src/application/dto/your_entity_list_dto.rs

#[derive(Debug, Clone)]
pub struct YourEntityListDTO {
    pub items: Vec<YourEntityDTO>,
}

#[derive(Debug, Clone)]
pub struct YourEntityDTO {
    pub id: String,
    pub name: String,
    // 必要なフィールドを追加
}

impl YourEntityListDTO {
    pub fn new(items: Vec<YourEntityDTO>) -> Self {
        Self { items }
    }
}
```

単一データを取得する場合：

```rust
// src/application/dto/your_entity_dto.rs

#[derive(Debug, Clone)]
pub struct YourEntityDTO {
    pub id: String,
    pub name: String,
    // 必要なフィールドを追加
}

impl YourEntityDTO {
    pub fn new(id: String, name: String) -> Self {
        Self { id, name }
    }
}
```

#### 1.2 mod.rsにDTOを追加

```rust
// src/application/dto/mod.rs に追加
mod your_entity_list_dto;

// 必要な型のみを明示的にエクスポート
pub use self::your_entity_list_dto::{YourEntityListDTO, YourEntityDTO};
```

```rust
// src/application/mod.rs のuse文に追加（必要な場合のみ）
pub use dto::{YourEntityListDTO, YourEntityDTO};
```

### Step 2: Application層 - Repository trait作成

```bash
touch src/application/repositories/your_entity_repository.rs
```

```rust
// src/application/repositories/your_entity_repository.rs
use crate::application::error::RepositoryError;
use crate::application::dto::YourEntityListDTO;

#[async_trait::async_trait]
pub trait YourEntityRepository {
    async fn find_all(&self) -> Result<YourEntityListDTO, RepositoryError>;
    // 必要に応じて他のメソッドを追加
}
```

```rust
// src/application/repositories/mod.rs に追加
mod your_entity_repository;

// traitのみを明示的にエクスポート（*は使用しない）
pub use your_entity_repository::YourEntityRepository;
```

### Step 3: Application層 - Query Handler作成

#### 3.1 Queryモデル作成（パラメータがある場合）

```bash
mkdir -p src/application/queries/models
touch src/application/queries/models/get_your_entity_list_query.rs
```

```rust
// src/application/queries/models/get_your_entity_list_query.rs

/// パラメータがない場合は不要
/// パラメータがある場合の例：
#[derive(Debug, Clone)]
pub struct GetYourEntityListQuery {
    pub page: Option<u32>,
    pub per_page: Option<u32>,
    pub filter: Option<String>,
}

impl GetYourEntityListQuery {
    pub fn new(page: Option<u32>, per_page: Option<u32>, filter: Option<String>) -> Self {
        Self { page, per_page, filter }
    }
}
```

#### 3.2 Query Handler作成

```bash
touch src/application/queries/handlers/get_your_entity_list_handler.rs
```

```rust
// src/application/queries/handlers/get_your_entity_list_handler.rs
use std::sync::Arc;
use crate::application::repositories::YourEntityRepository;
use crate::application::error::ApplicationError;
use crate::application::dto::YourEntityListDTO;

/// YourEntityリスト取得クエリハンドラ
pub struct GetYourEntityListHandler {
    your_entity_repository: Arc<dyn YourEntityRepository + Send + Sync>,
}

impl GetYourEntityListHandler {
    pub fn new(your_entity_repository: Arc<dyn YourEntityRepository + Send + Sync>) -> Self {
        Self { your_entity_repository }
    }

    /// クエリを実行
    pub async fn handle(&self) -> Result<YourEntityListDTO, ApplicationError> {
        println!("->> GetYourEntityListHandler::handle");
        
        let result = self.your_entity_repository.find_all().await?;
        
        Ok(result)
    }
}
```

#### 3.3 mod.rsにHandlerを追加

```rust
// src/application/queries/handlers/mod.rs に追加
pub mod get_your_entity_list_handler;

// Handlerのみを明示的にエクスポート
pub use get_your_entity_list_handler::GetYourEntityListHandler;
```

```rust
// src/application/queries/models/mod.rs に追加（Query modelがある場合）
mod get_your_entity_list_query;

// Queryのみを明示的にエクスポート  
pub use get_your_entity_list_query::GetYourEntityListQuery;
```

```rust
// src/application/mod.rs のuse文に追加（必要な場合のみ）
pub use queries::GetYourEntityListHandler;
```

### Step 4: Application層 - Dispatcher更新

```rust
// src/application/dispatcher.rs を更新
use crate::application::queries::handlers::GetYourEntityListHandler;
use crate::application::dto::YourEntityListDTO;

pub struct Dispatcher {
    // 既存のハンドラ...
    get_your_entity_list_handler: Arc<GetYourEntityListHandler>,
}

impl Dispatcher {
    pub fn new(
        // 既存のパラメータ...
        get_your_entity_list_handler: Arc<GetYourEntityListHandler>,
    ) -> Self {
        Self {
            // 既存のフィールド...
            get_your_entity_list_handler,
        }
    }

    /// 新しいクエリ実行メソッドを追加
    pub async fn execute_get_your_entity_list_query(&self) -> Result<YourEntityListDTO, ApplicationError> {
        self.get_your_entity_list_handler.handle().await
    }
}
```

### Step 5: Infrastructure層 - Repository実装

```bash
touch src/infrastructure/database/repositories_impl/sqlite_your_entity_repository.rs
```

```rust
// src/infrastructure/database/repositories_impl/sqlite_your_entity_repository.rs
use async_trait::async_trait;
use sqlx::{Row, SqlitePool};

use crate::application::repositories::YourEntityRepository;
use crate::application::error::RepositoryError;
use crate::application::dto::{YourEntityListDTO, YourEntityDTO};

/// SQLite実装のYourEntityRepository
/// Clean Architecture: Infrastructure層
pub struct SqliteYourEntityRepository {
    pool: SqlitePool,
}

impl SqliteYourEntityRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}

#[async_trait]
impl YourEntityRepository for SqliteYourEntityRepository {
    async fn find_all(&self) -> Result<YourEntityListDTO, RepositoryError> {
        // 実際のSQL実装（例）
        let rows = sqlx::query("SELECT id, name FROM your_entities ORDER BY name")
            .fetch_all(&self.pool)
            .await
            .map_err(|e| RepositoryError::QueryExecution(e.to_string()))?;

        let items: Vec<YourEntityDTO> = rows
            .into_iter()
            .map(|row| YourEntityDTO {
                id: row.get("id"),
                name: row.get("name"),
            })
            .collect();

        Ok(YourEntityListDTO::new(items))
    }
}
```

```rust
// src/infrastructure/database/repositories_impl/mod.rs に追加
mod sqlite_your_entity_repository;

// 実装クラスのみを明示的にエクスポート（*は使用しない）
pub use sqlite_your_entity_repository::SqliteYourEntityRepository;
```

### Step 6: Infrastructure層 - DI Container更新

```rust
// src/infrastructure/di/container.rs を更新
use crate::infrastructure::database::repositories_impl::SqliteYourEntityRepository;
use crate::application::repositories::YourEntityRepository;
use crate::application::queries::handlers::GetYourEntityListHandler;

pub struct Container {
    // 既存のリポジトリ...
    pub your_entity_repository: Arc<dyn YourEntityRepository + Send + Sync>,
    // dispatcher は既存
}

impl Container {
    /// プールを指定してコンテナを作成します
    async fn new_with_pool(pool: sqlx::SqlitePool) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        // 既存のリポジトリ...
        let your_entity_repository = Arc::new(SqliteYourEntityRepository::new(pool.clone()));
        
        // 既存のハンドラ...
        let get_your_entity_list_handler = Arc::new(GetYourEntityListHandler::new(your_entity_repository.clone()));
        
        // ディスパッチャを更新
        let dispatcher = Arc::new(Dispatcher::new(
            // 既存のハンドラ引数...
            get_your_entity_list_handler,
        ));
        
        Ok(Self {
            // 既存のフィールド...
            your_entity_repository,
            dispatcher,
        })
    }
}
```

### Step 7: Presentation層 - Response構造作成

```bash
mkdir -p src/presentation/your_entities/responses
touch src/presentation/your_entities/responses/your_entity_list_response.rs
```

```rust
// src/presentation/your_entities/responses/your_entity_list_response.rs
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct YourEntityListResponse {
    pub items: Vec<YourEntityListItemResponse>,
}

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct YourEntityListItemResponse {
    pub id: String,
    #[schema(nullable = false)]
    pub name: Option<String>,
    // フロントエンド要件に合わせたフィールド
}

impl YourEntityListResponse {
    pub fn new(items: Vec<YourEntityListItemResponse>) -> Self {
        Self { items }
    }
}
```

```rust
// src/presentation/your_entities/responses/mod.rs
mod your_entity_list_response;

// Response型のみを明示的にエクスポート
pub use your_entity_list_response::{YourEntityListResponse, YourEntityListItemResponse};
```

### Step 8: Presentation層 - Presenter作成

```bash
mkdir -p src/presentation/your_entities/presenters
touch src/presentation/your_entities/presenters/your_entity_list_presenter.rs
```

```rust
// src/presentation/your_entities/presenters/your_entity_list_presenter.rs
use crate::application::dto::YourEntityListDTO;
use crate::presentation::your_entities::responses::{YourEntityListResponse, YourEntityListItemResponse};

/// YourEntityリストプレゼンター
/// Clean Architecture: Interface Adapters層
/// アプリケーション層のDTOをHTTPレスポンス用DTOに変換する
pub struct YourEntityListPresenter;

impl YourEntityListPresenter {
    /// DTOをResponseに変換
    pub fn present(dto: YourEntityListDTO) -> YourEntityListResponse {
        let items = dto
            .items
            .into_iter()
            .map(|item| YourEntityListItemResponse {
                id: item.id,
                name: item.name,
            })
            .collect();

        YourEntityListResponse::new(items)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::application::dto::{YourEntityListDTO, YourEntityDTO};

    #[test]
    fn test_present() {
        let dto = YourEntityListDTO::new(vec![
            YourEntityDTO {
                id: "1".to_string(),
                name: "Test Item".to_string(),
            },
        ]);

        let response = YourEntityListPresenter::present(dto);
        
        assert_eq!(response.items.len(), 1);
        assert_eq!(response.items[0].id, "1");
        assert_eq!(response.items[0].name, "Test Item");
    }
}
```

```rust
// src/presentation/your_entities/presenters/mod.rs
mod your_entity_list_presenter;

// Presenterのみを明示的にエクスポート
pub use your_entity_list_presenter::YourEntityListPresenter;
```

### Step 9: Presentation層 - Controller作成

```bash
mkdir -p src/presentation/your_entities/controllers
touch src/presentation/your_entities/controllers/get_your_entity_list_controller.rs
```

```rust
// src/presentation/your_entities/controllers/get_your_entity_list_controller.rs
use axum::extract::State;
use axum::{Json, Router, routing::get};
use std::sync::Arc;

use crate::error::Result;
use crate::infrastructure::Container;
use crate::presentation::your_entities::presenters::YourEntityListPresenter;
use crate::presentation::your_entities::responses::YourEntityListResponse;
use crate::presentation::ErrorResponse;

/// Your Entity List Controller
pub struct GetYourEntityListController;

impl GetYourEntityListController {
    /// ルート定義
    pub fn routes() -> Router<Arc<Container>> {
        Router::new().route("/your-entities", get(handle))
    }
}

/// GET /your-entities - YourEntityリスト取得処理
#[utoipa::path(
    get,
    path = "/your-entities",
    operation_id = "get_your_entity_list",
    responses(
        (status = 200, description = "YourEntityリスト取得成功", body = YourEntityListResponse),
        (status = 500, description = "内部サーバーエラー", body = ErrorResponse)
    ),
    tag = "YourEntities"
)]
pub async fn handle(
    State(container): State<Arc<Container>>,
) -> Result<Json<YourEntityListResponse>> {
    println!("->> GetYourEntityListController::handle");

    let dispatcher = container.get_dispatcher();
    let result = dispatcher.execute_get_your_entity_list_query().await?;

    println!("->> GetYourEntityListController::handle - success");

    Ok(Json(YourEntityListPresenter::present(result)))
}
```

```rust
// src/presentation/your_entities/controllers/mod.rs
pub mod get_your_entity_list_controller;

// Controllerクラスのみを明示的にエクスポート
pub use get_your_entity_list_controller::GetYourEntityListController;
```

### Step 10: Presentation層 - モジュール統合

```bash
touch src/presentation/your_entities/mod.rs
```

```rust
// src/presentation/your_entities/mod.rs
pub mod controllers;  // ルーティングで必要なため pub
mod presenters;       // 内部使用のみ
mod responses;        // 内部使用のみ

use axum::Router;
use std::sync::Arc;
use crate::infrastructure::Container;

// 外部から必要なもののみをエクスポート
use controllers::GetYourEntityListController;
use presenters::YourEntityListPresenter;
pub use responses::YourEntityListResponse;  // レスポンス型は公開が必要

/// YourEntitiesモジュールの全ルート定義
/// Clean Architecture: 関連するControllerのルートを統合
pub fn routes() -> Router<Arc<Container>> {
    Router::new()
        .merge(GetYourEntityListController::routes())
}
```

### Step 11: ルートの登録

```rust
// src/presentation/routes.rs を更新
use crate::presentation::your_entities;

pub fn routes() -> Router<Arc<Container>> {
    Router::new()
        // 既存のルート...
        .merge(your_entities::routes())
        // その他のルート...
}
```

```rust
// src/presentation/mod.rs を更新（必要に応じて）
mod your_entities;
```

### Step 12: OpenAPI/Swagger設定 - 新しいエンドポイントをSwagger UIに追加

新しく作成したエンドポイントをSwagger UIで確認できるように、OpenAPI設定を更新します。

#### 12.1 Response型のインポート追加

```rust
// src/presentation/swagger/openapi.rs のuse文に追加
use crate::presentation::your_entities::responses::{
    YourEntityListResponse,
    YourEntityListItemResponse,
};
```

#### 12.2 パス（エンドポイント）の追加

```rust
// src/presentation/swagger/openapi.rs の #[openapi] マクロ内のpaths()セクションに追加
#[openapi(
    paths(
        // 既存のパス...
        crate::presentation::products::controllers::get_product_controller::handle,
        crate::presentation::products::controllers::get_product_list_controller::handle,
        crate::presentation::categories::controllers::get_categorie_list_controller::handle,
        crate::presentation::colors::controllers::get_color_list_controller::handle,
        crate::presentation::variants::controllers::find_variants_controller::handle,
        // 新しいパスを追加
        crate::presentation::your_entities::controllers::get_your_entity_list_controller::handle,
    ),
    // ...
)]
```

#### 12.3 スキーマコンポーネントの追加

```rust
// src/presentation/swagger/openapi.rs の components()セクションに追加
components(
    schemas(
        // 既存のスキーマ...
        ProductResponse,
        ProductListResponse,
        CategoryListResponse,
        ColorListResponse,
        VariantListResponse,
        ErrorResponse,
        // 新しいスキーマを追加
        YourEntityListResponse,
        YourEntityListItemResponse,
    )
),
```

#### 12.4 タグの追加（必要に応じて）

```rust
// src/presentation/swagger/openapi.rs のtags()セクションに追加
tags(
    // 既存のタグ...
    (name = "Products", description = "商品関連のAPI"),
    (name = "Categories", description = "カテゴリ関連のAPI"),
    (name = "Colors", description = "色関連のAPI"),
    (name = "Variants", description = "バリアント関連のAPI"),
    // 新しいタグを追加
    (name = "YourEntities", description = "YourEntity関連のAPI"),
),
```

#### 12.5 完全なopenapi.rs更新例

```rust
// src/presentation/swagger/openapi.rs
use utoipa::OpenApi;

use crate::presentation::products::responses::{
    ProductResponse, 
    ProductListResponse, 
    ProductListItemResponse, 
    VariantResponse
};
use crate::presentation::categories::responses::{
    CategoryListResponse,
    CategoryResponse
};
use crate::presentation::colors::{
    ColorListResponse,
    ColorListItemResponse
};
use crate::presentation::variants::responses::{
    VariantListResponse,
    VariantListItemResponse
};
use crate::presentation::your_entities::responses::{
    YourEntityListResponse,
    YourEntityListItemResponse,
};
use crate::presentation::ErrorResponse;

/// OpenAPI仕様書の定義
#[derive(OpenApi)]
#[openapi(
    paths(
        crate::presentation::products::controllers::get_product_controller::handle,
        crate::presentation::products::controllers::get_product_list_controller::handle,
        crate::presentation::categories::controllers::get_categorie_list_controller::handle,
        crate::presentation::colors::controllers::get_color_list_controller::handle,
        crate::presentation::variants::controllers::find_variants_controller::handle,
        crate::presentation::your_entities::controllers::get_your_entity_list_controller::handle,
    ),
    components(
        schemas(
            ProductResponse,
            ProductListResponse,
            ProductListItemResponse,
            VariantResponse,
            CategoryListResponse,
            CategoryResponse,
            ColorListResponse,
            ColorListItemResponse,
            VariantListResponse,
            VariantListItemResponse,
            YourEntityListResponse,
            YourEntityListItemResponse,
            ErrorResponse
        )
    ),
    tags(
        (name = "Products", description = "商品関連のAPI"),
        (name = "Categories", description = "カテゴリ関連のAPI"),
        (name = "Colors", description = "色関連のAPI"),
        (name = "Variants", description = "バリアント関連のAPI"),
        (name = "YourEntities", description = "YourEntity関連のAPI"),
    ),
    info(
        title = "ECサイト API",
        description = "Clean Architectureを適用したECサイトのREST API",
        version = "1.0.0",
        contact(
            name = "Development Team",
            email = "dev@example.com"
        )
    ),
    servers(
        (url = "http://localhost:4000", description = "Development server"),
        (url = "https://api.example.com", description = "Production server")
    )
)]
pub struct ApiDoc;
```

#### 12.6 Swagger UI確認

1. サーバーを起動: `cd app/backend && cargo run`
2. Swaggerエンドポイントにアクセス: `http://localhost:4000/api-docs/openapi.json`
3. 新しいエンドポイントが追加されていることを確認
4. "Try it out"ボタンでエンドポイントをテスト

### OpenAPI設定のチェックリスト

- [ ] Response型のインポートを追加
- [ ] paths()に新しいエンドポイントを追加  
- [ ] components/schemas()に新しいResponse型を追加
- [ ] tags()に新しいタグを追加（必要に応じて）
- [ ] Swagger UIで新しいエンドポイントが表示されることを確認
- [ ] "Try it out"でAPIが正常に動作することを確認

### OpenAPI関連のトラブルシューティング

1. **Swagger UIに表示されない**
   - openapi.rsのpaths()に追加漏れ
   - use文でResponse型のインポート漏れ

2. **スキーマエラー**
   - components/schemas()に型の追加漏れ
   - Response構造体の`#[derive(ToSchema)]`追加漏れ

3. **タグが表示されない**
   - Controller内の`#[utoipa::path]`マクロのtag指定確認
   - openapi.rsのtags()セクション確認

## チェックリスト

実装完了後、以下をチェックしてください：

### コンパイルチェック

- [ ] `cd app/backend && cargo check` でコンパイルエラーなし
- [ ] `cd app/backend && cargo clippy` で警告なし
- [ ] `cd app/backend && cargo fmt` でフォーマット済み

### mod.rs設計チェック

- [ ] ワイルドカード（`*`）を使用していない
- [ ] 必要最小限のもののみをpubにしている
- [ ] 内部モジュールは`mod`（pubなし）で定義している
- [ ] 明示的に型名を指定してエクスポートしている
- [ ] 層間のインターフェースが明確に定義されている

### 機能チェック

- [ ] `cd app/backend && cargo run` でサーバー起動
- [ ] `curl http://localhost:4000/your-entities` でレスポンス確認
- [ ] Swagger UI (`http://localhost:4000/swagger-ui/`) で仕様確認

### テストチェック

- [ ] `cd app/backend && cargo test` でテスト通過
- [ ] Presenterのユニットテスト実装
- [ ] 必要に応じてRepositoryのテスト実装

## トラブルシューティング

### よくあるエラー

1. **コンパイルエラー: "trait ... is not implemented"**
   - `use` 文の追加漏れ
   - `#[async_trait]` の追加漏れ

2. **ランタイムエラー: "method not found"**
   - Dispatcherにメソッド追加漏れ
   - DIコンテナにハンドラ登録漏れ

3. **HTTP 404エラー**
   - ルート登録漏れ
   - パス指定ミス

4. **HTTP 500エラー**
   - エラーハンドリング不備
   - リポジトリ実装の不具合

5. **データベース接続エラー**
   - SQLitePoolの渡し方の問題
   - SQLiteファイルの存在確認

6. **モジュール可視性エラー**
   - 必要な型がpubになっていない
   - 不適切な`*`使用によるコンパイルエラー
   - mod.rsでの明示的エクスポート漏れ

### デバッグのコツ

1. `println!` でログを仕込む
2. `cd app/backend && cargo run` で直接エラーメッセージを確認
3. 各層を個別にテストする
4. 簡単なモックデータから始める
5. `bacon` コマンドで継続的なビルドチェック

## 参考実装

### 実装済みエンドポイント例

- **シンプルな例**: `/colors` エンドポイント
  - ファイル: `src/presentation/colors/`
  - パラメータなし、リスト取得のみ

- **複雑な例**: `/products` エンドポイント  
  - ファイル: `src/presentation/products/`
  - ページネーション、リッチなデータ構造

- **パラメータあり例**: `/variants` エンドポイント
  - ファイル: `src/presentation/variants/`
  - POSTリクエスト、Request DTO使用

### 実装パターンの使い分け

1. **シンプルなGETエンドポイント**: colorsパターンを参考
2. **複雑なGETエンドポイント**: productsパターンを参考  
3. **POSTパラメータ**: variantsパターンを参考

新しくエンドポイントを作成する際は、これらの既存実装を参考にしてください。

## 追加情報

### ディレクトリ構造の概要

```
app/backend/src/
├── application/
│   ├── commands/           # コマンド（状態変更）
│   ├── queries/           # クエリ（データ取得）
│   ├── dto/               # データ転送オブジェクト
│   ├── repositories/      # リポジトリインターフェース
│   ├── dispatcher.rs      # CQRSディスパッチャ
│   └── error.rs          # アプリケーションエラー
├── domain/
│   ├── models/           # ドメインモデル
│   └── error.rs         # ドメインエラー
├── infrastructure/
│   ├── database/        # データベース関連
│   └── di/             # 依存注入設定
└── presentation/
    ├── products/       # 商品関連エンドポイント
    ├── categories/     # カテゴリ関連エンドポイント
    ├── colors/         # 色関連エンドポイント
    ├── variants/       # バリアント関連エンドポイント
    ├── common/         # 共通コンポーネント
    ├── swagger/        # Swagger/OpenAPI
    └── routes.rs       # ルート統合
```

### 命名規則

- **DTO**: `{Entity}DTO`, `{Entity}ListDTO`
- **Repository**: `{Entity}Repository`
- **Handler**: `Get{Entity}ListHandler`, `Find{Entity}sHandler`
- **Controller**: `Get{Entity}ListController`
- **Presenter**: `{Entity}ListPresenter`
- **Response**: `{Entity}ListResponse`, `{Entity}Response`

### mod.rsの適切な書き方

#### ❌ 悪い例 (ワイルドカード使用)

```rust
pub use module::*;  // すべてをエクスポート（避けるべき）
```

#### ✅ 良い例 (明示的エクスポート)

```rust
mod module_name;  // pubは不要（内部モジュール）

// 必要なもののみを明示的にエクスポート
pub use module_name::{SpecificType, AnotherType};
```

#### 層別のpub使用指針

**Application層:**
- DTOは必要な型のみpub
- Repositoryはtraitのみpub
- Handlerは具象クラスのみpub

**Infrastructure層:**
- Repository実装は具象クラスのみpub
- DIコンテナは必要なもののみpub

**Presentation層:**
- Controllerは通常pubで必要
- Presenterは内部使用のみ
- Response型はAPIで必要なためpub
- Request型はAPIで必要なためpub

## パラメータ付きエンドポイントの場合

### Request構造体の追加

```bash
mkdir -p src/presentation/your_entities/requests
touch src/presentation/your_entities/requests/get_your_entities_request.rs
```

```rust
// src/presentation/your_entities/requests/get_your_entities_request.rs
use serde::{Deserialize, Serialize};
use utoipa::ToSchema;
use crate::application::queries::models::GetYourEntityListQuery;

#[derive(Debug, Clone, Serialize, Deserialize, ToSchema)]
#[serde(rename_all = "camelCase")]
pub struct GetYourEntitiesRequest {
    pub filter_ids: Vec<String>,
    pub include_inactive: Option<bool>,
}

impl GetYourEntitiesRequest {
    pub fn to_query(&self) -> Result<GetYourEntityListQuery, String> {
        Ok(GetYourEntityListQuery::new(
            self.filter_ids.clone(),
            self.include_inactive.unwrap_or(false),
        ))
    }
}
```

```rust
// src/presentation/your_entities/requests/mod.rs
mod get_your_entities_request;

// Request型のみを明示的にエクスポート
pub use get_your_entities_request::GetYourEntitiesRequest;
```

### POSTエンドポイントのController更新

```rust
// Controllerでパラメータを受け取る場合
use axum::extract::{State, Json as RequestJson};

pub async fn handle(
    State(container): State<Arc<Container>>,
    RequestJson(request): RequestJson<GetYourEntitiesRequest>,
) -> Result<Json<YourEntityListResponse>> {
    println!("->> GetYourEntityListController::handle");

    let query = request.to_query()
        .map_err(|_| crate::application::error::ApplicationError::Validation(
            "Invalid request format".to_string()
        ))?;
    
    let dispatcher = container.get_dispatcher();
    let result = dispatcher.execute_get_your_entity_list_query(query).await?;

    Ok(Json(YourEntityListPresenter::present(result)))
}
```

### POSTルートの定義

```rust
// POST エンドポイントの場合
use axum::routing::post;

impl GetYourEntityListController {
    pub fn routes() -> Router<Arc<Container>> {
        Router::new().route("/your-entities", post(handle))
    }
}
```

## 現在の実装パターンまとめ

### CQRSディスパッチャパターン

現在の実装では、すべてのコマンドとクエリの実行は`Dispatcher`を通じて行われます：

```rust
// Controller内での典型的な実装
let dispatcher = container.get_dispatcher();
let result = dispatcher.execute_get_your_entity_list_query().await?;
```

### DIコンテナパターン

コンテナは各リポジトリの実装とディスパッチャを保持し、SQLitePoolを各リポジトリに注入します：

```rust
// Container内での典型的なリポジトリ初期化
let your_entity_repository = Arc::new(SqliteYourEntityRepository::new(pool.clone()));
let handler = Arc::new(GetYourEntityListHandler::new(your_entity_repository.clone()));
```

### Repository実装パターン

各リポジトリはコンストラクタでSQLitePoolを受け取り、内部で保持します：

```rust
pub struct SqliteYourEntityRepository {
    pool: SqlitePool,
}

impl SqliteYourEntityRepository {
    pub fn new(pool: SqlitePool) -> Self {
        Self { pool }
    }
}
```

このパターンにより、データベース接続の管理が簡潔になり、テストも容易になります。

### mod.rs設計原則

#### Clean Architectureでのモジュール公開ルール

1. **最小権限の原則**: 必要最小限のもののみをpubにする
2. **明示的エクスポート**: `*`によるワイルドカード使用を避ける
3. **層間インターフェースの限定**: 各層のAPIを明確に定義する
4. **内部実装の隠蔽**: 実装の詳細は外部に公開しない

#### 良い例と悪い例

**❌ 悪い実装:**
```rust
// 何でもかんでもpubにする
pub mod internal_module;
pub use internal_module::*;  // 全部エクスポート
```

**✅ 良い実装:**
```rust
// 必要なもののみを公開
mod internal_module;  // 内部モジュールはpubにしない
pub use internal_module::PublicInterface;  // 必要な部分のみ
```

この設計により、コードの保守性と可読性が向上し、依存関係が明確になります。
